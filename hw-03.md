# Домашнее задание к занятию "`Система мониторинга Zabbix. Часть 2`" - `Борис Сидоров`

---
---

### Задание 1
Создайте свой шаблон, в котором будут элементы данных, мониторящие загрузку CPU и RAM хоста.

#### Процесс выполнения
1. Выполняя ДЗ сверяйтесь с процессом отражённым в записи лекции.
2. В веб-интерфейсе Zabbix Servera в разделе Templates создайте новый шаблон
3. Создайте Item который будет собирать информацию об загрузке CPU в процентах
4. Создайте Item который будет собирать информацию об загрузке RAM в процентах

#### Требования к результату
- [ ] Прикрепите в файл README.md скриншот страницы шаблона с названием «Задание 1»

 ---

### Решение 1

Для создания нового шаблона перешел в меню templates: **Data collection > templates**
Задал понятное имя для нового шаблона **CPU and RAM**, а также принадлежность к новой группе my_groups:
![new template](screen/hw-03.md/task-1/hw-03-1.1.png)

для нового шаблона так же задал два макроса со значением **5** и **15**. Данные макросы буду использовать для указания период обновления, так как система мониторинга тестовая, значения указаны низкие для комфортного тестирования.
![new macros](screen/hw-03.md/task-1/hw-03-1.2.png)

следующим шагом создал необходимые items для моего шаблона.
Первый items будет отображать процент использования RAM на хосте. Для этого использовал:
- **Name** RAM load%
- **Type** Zabbix agent
- **Key** vm.memory.size[pused]
- **Unit** %
- **Update interval** {$UPDATE_TIME1}
![property items RAM load](screen/hw-03.md/task-1/hw-03-1.3.png)

для реализации метри по общего процента нагрузки CPU я использовал 2 items. В первом из типа агента взял ключ по выводу процента бездействия CPU:
- **Name** CPU idle%
- **Type** Zabbix agent
- **Key** system.cpu.util[,idle]
- **Unit** %
- **Update interval** {$UPDATE_TIME1}
![property items CPU idle](screen/hw-03.md/task-1/hw-03-1.4.png)

а второй items использовал type Calculated в котором будет высчитывать процент из простой формулы. 100 - последние данные простоя CPU:
- **Name** CPU load%
- **Type** Calculated
- **Key** cpu.totalload (уникальное придуманное имя ключа)
- **Formula** 100 - last(//system.cpu.util[,idle]) 
- **Unit** %
- **Update interval** {$UPDATE_TIME1}
![property items CPU load](screen/hw-03.md/task-1/hw-03-1.5.png)

В итоге получился следующий шаблон:
![the created template](screen/hw-03.md/task-1/hw-03-1.6.png)

---
---

### Задание 2
Добавьте в Zabbix два хоста и задайте им имена <фамилия и инициалы-1> и <фамилия и инициалы-2>. Например: ivanovii-1 и ivanovii-2.

#### Процесс выполнения
1. Выполняя ДЗ сверяйтесь с процессом отражённым в записи лекции.
2. Установите Zabbix Agent на 2 виртмашины, одной из них может быть ваш Zabbix Server
3. Добавьте Zabbix Server в список разрешенных серверов ваших Zabbix Agentов
4. Добавьте Zabbix Agentов в раздел Configuration > Hosts вашего Zabbix Servera
5. Прикрепите за каждым хостом шаблон Linux by Zabbix Agent
6. Проверьте что в разделе Latest Data начали появляться данные с добавленных агентов

#### Требования к результату
- [ ] Результат данного задания сдавайте вместе с заданием 3

 ---

### Решение 2

Хосты были добавлены ещё на этапе настройки zabbix, по требованию задания отредактировал названия хостов.
![hosts](screen/hw-03.md/task-2/hw-03-2.1.png)

---
---

### Задание 3
Привяжите созданный шаблон к двум хостам. Также привяжите к обоим хостам шаблон Linux by Zabbix Agent.

#### Процесс выполнения
1. Выполняя ДЗ сверяйтесь с процессом отражённым в записи лекции.
2. Зайдите в настройки каждого хоста и в разделе Templates прикрепите к этому хосту ваш шаблон
3. Так же к каждому хосту привяжите шаблон Linux by Zabbix Agent
4. Проверьте что в раздел Latest Data начали поступать необходимые данные из вашего шаблона

#### Требования к результату
- [ ] Прикрепите в файл README.md скриншот страницы хостов, где будут видны привязки шаблонов с названиями «Задание 2-3». Хосты должны иметь зелёный статус подключения

 ---

 ### Решение 3

Так как в zabbix нет возможности добавить два шаблона в которых есть items с одними и теми же ключами, я **удалил** эти ключи из шаблона **Linux by Zabbix agent**  тем самым мой кастомный шаблон будет дополнять шаблон предоставленный из коробки.
![added templates on host 1](screen/hw-03.md/task-3/hw-03-3.1.png)
![added templates on host 2](screen/hw-03.md/task-3/hw-03-3.2.png)

итоговый скрин в разделе **monitoring > hosts**
![added templates on host 1 & hsot 2](screen/hw-03.md/task-3/hw-03-3.3.png)

---
---

### Задание 4
Создайте свой кастомный дашборд.

#### Процесс выполнения
1. Выполняя ДЗ сверяйтесь с процессом отражённым в записи лекции.
2. В разделе Dashboards создайте новый дашборд
3. Разместите на нём несколько графиков на ваше усмотрение.

#### Требования к результату
- [ ] Прикрепите в файл README.md скриншот дашборда с названием «Задание 4»

 ---

### Решение 4

Создал новую доску где разместил 3 графика по нагрузке CPU, RAM, NET, также добавил виджет с появляющимися проблемами
![new dashboard](screen/hw-03.md/task-4/hw-03-4.1.png)

---
---

### Задание 5* со звёздочкой
Создайте карту и расположите на ней два своих хоста.

#### Процесс выполнения
1. Настройте между хостами линк.
2. Привяжите к линку триггер, связанный с agent.ping одного из хостов, и установите индикатором сработавшего триггера красную пунктирную линию.
3. Выключите хост, чей триггер добавлен в линк. Дождитесь срабатывания триггера.

#### Требования к результату
- [ ] Прикрепите в файл README.md скриншот карты, где видно, что триггер сработал, с названием «Задание 5» 

 ---

### Решение 5

Перед созданием карты нашел в сети схему маленького офиса и загрузил её в настройках **Administration > general > image > type Background**. Затем в меню **Monitoring > Maps** уже дефолтную карту **Local network** отредактировал выставив ширину и высоту подходящую под скачанное изображение, в поле **Background image** выбрал свой фон загруженный ранее. На карте добавил два схематичных объекта которыми будут выступать хосты созданные в предыдущем задании, в качесте имени использовал макрос **{HOST.NAME}**.

Перед созданием связи между хостами я создал для этой цели триггер для **items agent.ping**:
- **name**: Agent on {HOST.NAME} is unvailable
- **Expression**: nodata(/Linux by Zabbix agent/agent.ping,1m)=1
![new trigger](screen/hw-03.md/task-5/hw-03-5.1.png)

Триггер будет срабатывать если значение **nodata** будет возвращаться **0** и проверка будет осуществляться раз в минуту. Главное, что я изменил период работы **items Zabbix agent ping** на **30s** во избежания ложных данных от триггера.
![congigured items agent.ping](screen/hw-03.md/task-5/hw-03-5.2.png)

возвращаясь к создаваемой карте между хостов сделал связь и поставил триггер в случае если на первом хосте не будет связи с zabbix агентом. Когда триггер сработает выбрал окраску связи в красную пунктирную линию
![connectivity between hosts](screen/hw-03.md/task-5/hw-03-5.3.png)

в итоге карта выглядит следующим образом
![my new map](screen/hw-03.md/task-5/hw-03-5.4.png)

отключу zabbix agent на первом хосте и посмотрю, что произойдет
![test trigger](screen/hw-03.md/task-5/hw-03-5.5.png)

---
---

### Задание 6* со звёздочкой
Создайте UserParameter на bash и прикрепите его к созданному вами ранее шаблону. Он должен вызывать скрипт, который:
- при получении 1 будет возвращать ваши ФИО,
- при получении 2 будет возвращать текущую дату.

#### Требования к результату
- [ ] Прикрепите в файл README.md код скрипта, а также скриншот Latest data с результатом работы скрипта на bash, чтобы был виден результат работы скрипта при отправке в него 1 и 2
 
 ---

### Решение 6

Первым делом приступил к написания основного файл скритпа который будет выполнять поставленную задачу, напечатать ФИО при передаваемом аргументе со значением 1, напечатать текущую дату при передаваемом аргументе со значением 2. Скрипт **name_date.sh** получился таким:
```bash
#!/bin/bash
VALID_ARG=(1 2)

is_valid_args(){
        local arg="$1"
        for v in "${VALID_ARG[@]}"; do
                if [[ "$v" == "$arg" ]]; then
                        return 0
                fi
        done
        return 1
}

custom_parameters(){
    local is_first=true

    for arg in "$@"; do

        if [[ "$is_first" == false ]]; then
            echo -n " "
        fi

        if  [[ "$arg" == "1" ]]; then echo -n "Сидоров Борис Сергеевич";
        elif [[ "$arg" == "2" ]]; then echo -n "$(date "+%Y-%m-%d %H:%M:%S")"
        fi

        is_first=false
    done 
    echo           
}

all_valid=true
for arg in "$@"; do
    if ! is_valid_args "$arg"; then
        echo "Invalid argument: $arg"
        all_valid=false
    fi
done

if [[ "$#" -gt 0 && "$#" -lt 3 && "$all_valid" == true ]]; then
    if is_valid_args "$1"; then
        custom_parameters "$@"
    else echo "Invalid argument: $1"
    fi
else echo "Usage: <1|2>"
fi
```

Для пользовательских параметров можно было сделать намного проще без использования функции циклов в нем, не добавлять функцию на проверку валидности, но решил вспомнить пройденный материал по bash и использовать изученные навыки. В скрипте две функции на проверку валидности введенных аргументов и основная функция вывода текста в зависимости от аргумента. После функций описано условие при котором будет запускаться основная функция по выводу текста.
Разместил этот скрипт в том же пути где буду создавать конфигурационный файл 
**/etc/zabbix/zabbix_agentd.d/**

Следующим шагом создал конфигурационный файл **custome_parametrs.conf** в котором через директиву **UserParameter=** указала название ключа **name_date[*]** которое буду использовать при добавления нового items в web интерфейсе zabbix, так как скрипт на bash указал одноименное название пакета который будет запускать скрипт и абсолютный путь где располагается этот скрипт **bash /etc/zabbix/zabbix_agentd.d/name_date.sh** после чего какие аргументы можно использовать при вызове ключа **$1 $2**. В итоге получился конфигурационный файл с таким содержимым:

**UserParameter=name_date[*], bash /etc/zabbix/zabbix_agentd.d/name_date.sh $1 $2**

Таким образом по пути /etc/zabbix/zabbix_agentd.d/ у меня располагается два файла
![...zabbix_agentd.d/](screen/hw-03.md/task-6/hw-03-6.1.png)

Следующий шаг, добавляю в мой шаблон **CPU and RAM** новый items с название **Print name and date** со следующими значениями
![Print name and date](screen/hw-03.md/task-6/hw-03-6.2.png)

Скрин последних данных полученных от нового items и скрин с доски куда я добавил отчет по этой метрике
![last_date new items](screen/hw-03.md/task-6/hw-03-6.3.png)

![dashboard nwe_items](screen/hw-03.md/task-6/hw-03-6.4.png)

---
---

### Задание 7* со звёздочкой
Доработайте Python-скрипт из лекции, создайте для него UserParameter и прикрепите его к созданному вами ранее шаблону. 
Скрипт должен:
- при получении 1 возвращать ваши ФИО,
- при получении 2 возвращать текущую дату,
- делать всё, что делал скрипт из лекции.

- [ ] Прикрепите в файл README.md код скрипта в Git. Приложите в Git скриншот Latest data с результатом работы скрипта на Python, чтобы были видны результаты работы скрипта при отправке в него 1, 2, -ping, а также -simple_print.*
 
 ---

### Решение 7

В скрипте из презентации я добавил просто два условия **elif** в котором будет проверяться передаваемый аргумент и если он равен значению **1** то будет выводиться в консоль текс, мой ФИО. В другом условие если значение равно **2** то будет выводиться переменная **current_time** в которую ранее добавил вывоз класса **datetime** внутри модуля **datetime** и метода класса **now** с формартирование **strftime**, получается что-то похоже на команду **date в bash**. По аналогии с другими импортируемыми библиотеками я также добавил и **import datetime**
По итогу скрипт получился таким:

```py
import sys
import os
import re
import datetime
if (sys.argv[1] == '-ping'): # Если -ping
	result=os.popen("ping -c 1 " + sys.argv[2]).read() # Делаем пинг по заданному адресу
	
	result=re.findall(r"time=(.*) ms", result) # Выдёргиваем из результата время
	
	print(result[0]) # Выводим результат в консоль
	
elif (sys.argv[1] == '-simple_print'): # Если simple_print
	print(sys.argv[2]) # Выводим в консоль содержимое sys.arvg[2]

elif (sys.argv[1] == '1'):
	print("Сидоров Борис Сергеевич") # Выводить в консоль ФИО

elif (sys.argv[1] == '2'):
	current_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
	print(current_time) # Выводить в консоль дату и время

else: # Во всех остальных случаях
	print(f"unknown input: {sys.argv[1]}") # Выводим непонятый запрос в консоль
```
Далее так же как как и в предыдущем задании я разметил скрипт на python в директории **/etc/zabbix/zabbix_agentd.d/** с наименованием **py_script.py**
![py_script.py](screen/hw-03.md/task-7/hw-03-7.1.png)

в файле **custome_parametrs.conf** я добавил ещё 3 ключа, 2 как было показано в лекциях и ещё одну уже под требования задачи на возможность передать один аргумент. В итоге получилось 3 ключа **ping_py[*]**; **simple_print_py[*]**; **fio_or_date_print_py[*]**.
![custome_parametrs.conf](screen/hw-03.md/task-7/hw-03-7.2.png)

Перезагрузив демон на хосте приступил к добавлению новых items в web интерфейсе в моём созданном шаблоне:
- **Print Date** c ключом **fio_or_date_print_py[2]** # значение 2 будет выводить дату
- **Print FIO** с ключом **fio_or_date_print_py[1]** # значение 1 будет выводить ФИО
- **Print Ping IP zabbix_server** с ключем **ping_py[192.168.1.69]** # в -ping передается явно ip адрес заббикс сервера
- **Print simple_print** с ключем **simple_print_py[test_msg]** # в -simple_print передается текст test_msg 
![new_items](screen/hw-03.md/task-7/hw-03-7.3.png)

Скрин вывода последних данных по созданным items
![last_date](screen/hw-03.md/task-7/hw-03-7.4.png)

---
---

### Задание 8* со звёздочкой

Настройте автообнаружение и прикрепление к хостам созданного вами ранее шаблона.

#### Требования к результату
- [ ] Прикрепите в файл README.md скриншот правила обнаружения, а также скриншот страницы Discover, где видны оба хоста.*

 ---

### Решение 8

Для начала я удалил все хосты которые были на мониторинге
![deleted_hosts](screen/hw-03.md/task-8/hw-03-8.1.png)

далее в разделе **Data collection > Discovery** создал правило с именем **Local host** в котором будет сканироваться **диапазон ip 192.168.1.60-69** с интервалом обновления 1 минуту, тип проверки добавил **Zabbix agent "system.uname"**, уникальность устройств имя хоста и отображаемое имя также через Zabbix agent "system.uname"
![Discovery_rule](screen/hw-03.md/task-8/hw-03-8.2.png)

теперь для того чтобы новые обнаруженные хосты сразу были добавлены в мою ранее созданную группу local_vm и прилинкован мой шаблон CPU and RAM необходимо добавить действия по обнаружению. В моей версии заббикс это делается перейдя по пути Alerts > Actions > Discovery actions. Создаю новый actions
![Actions](screen/hw-03.md/task-8/hw-03-8.3.png)

и следующие операции в нем
![actions_operations](screen/hw-03.md/task-8/hw-03-8.4.png)

Теперь новые просканированные хосты сразу будут добавлены в мою группу с прилинкованным шаблоном
![result_added_hosts](screen/hw-03.md/task-8/hw-03-8.5.png)

скрин страницы обнаружения Discovery
![status_discovery](screen/hw-03.md/task-8/hw-03-8.6.png)

---
---

### Задание 9* со звёздочкой

Доработайте скрипты Vagrant для 2-х агентов, чтобы они были готовы к автообнаружению сервером, а также имели на борту разработанные вами ранее параметры пользователей.

- [ ] Приложите в GitHub файлы Vagrantfile и zabbix-agent.sh.*

## Критерии оценки

1. Выполнено минимум 4 обязательных задания
2. Прикреплены требуемые скриншоты, код и файлы 
3. Задание оформлено в шаблоне с решением и опубликовано на GitHub

---

### Решение 9

---
---

